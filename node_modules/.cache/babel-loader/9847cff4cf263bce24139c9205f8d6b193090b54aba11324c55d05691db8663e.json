{"ast":null,"code":"/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n) {\n  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain() {\n  const id = a => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a, b) => c => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  const encode = args.map(x => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map(x => x.decode).reduce(wrap, id);\n  return {\n    encode,\n    decode\n  };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n  return {\n    encode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map(i => {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n        return alphabet[i];\n      });\n    },\n    decode: input => {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n      return input.map(letter => {\n        if (typeof letter !== 'string') throw new Error(`alphabet.decode: not string element=${letter}`);\n        const index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n        return index;\n      });\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join() {\n  let separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: from => {\n      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n      for (let i of from) if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n      return from.join(separator);\n    },\n    decode: to => {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    }\n  };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits) {\n  let chr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '=';\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode(data) {\n      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      for (let i of data) if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n      while (data.length * bits % 8) data.push(chr);\n      return data;\n    },\n    decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      for (let i of input) if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n      let end = input.length;\n      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return {\n    encode: from => from,\n    decode: to => fn(to)\n  };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data);\n  digits.forEach(d => {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n  });\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < digits.length; i++) {\n      const digit = digits[i];\n      const digitBase = from * carry + digit;\n      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      const rounded = Math.floor(digitBase / to);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n      if (!done) continue;else if (!rounded) pos = i;else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */(a, b) => !b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */(from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const mask = 2 ** to - 1;\n  const res = [];\n  for (const n of data) {\n    assertNumber(n);\n    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = carry << from | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);\n    carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = carry << to - pos & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n  assertNumber(num);\n  return {\n    encode: bytes => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), 2 ** 8, num);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of numbers');\n      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n    }\n  };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits) {\n  let revPadding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n  return {\n    encode: bytes => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of numbers');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function () {\n    try {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode(data) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const checksum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode(data) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const newChecksum = fn(payload).slice(0, len);\n      const oldChecksum = data.slice(-len);\n      for (let i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    }\n  };\n}\n// prettier-ignore\nexport const utils = {\n  alphabet,\n  chain,\n  checksum,\n  convertRadix,\n  convertRadix2,\n  radix,\n  radix2,\n  join,\n  padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16 = /* @__PURE__ */chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = /* @__PURE__ */chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32nopad = /* @__PURE__ */chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\nexport const base32hex = /* @__PURE__ */chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32hexnopad = /* @__PURE__ */chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\nexport const base32crockford = /* @__PURE__ */chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(s => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64nopad = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nexport const base64url = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = abc => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = /* @__PURE__ */genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = /* @__PURE__ */genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = /* @__PURE__ */genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n  encode(data) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n    }\n    return res;\n  },\n  decode(str) {\n    let res = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  }\n};\nexport const createBase58check = sha256 => chain(checksum(4, data => sha256(sha256(data))), base58);\n// legacy export, bad name\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n  }\n  return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words) {\n  let encodingConst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ c >> 5;\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n  function encode(prefix, words) {\n    let limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 90;\n    if (typeof prefix !== 'string') throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n    if (words instanceof Uint8Array) words = Array.from(words);\n    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n    if (prefix.length === 0) throw new TypeError(`Invalid prefix length ${prefix.length}`);\n    const actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n  }\n  function decode(str) {\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 90;\n    if (typeof str !== 'string') throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return {\n      prefix,\n      words\n    };\n  }\n  const decodeUnsafe = unsafeWrapper(decode);\n  function decodeToBytes(str) {\n    const {\n      prefix,\n      words\n    } = decode(str, false);\n    return {\n      prefix,\n      words,\n      bytes: fromWords(words)\n    };\n  }\n  function encodeFromBytes(prefix, bytes) {\n    return encode(prefix, toWords(bytes));\n  }\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords\n  };\n}\nexport const bech32 = /* @__PURE__ */genBech32('bech32');\nexport const bech32m = /* @__PURE__ */genBech32('bech32m');\nexport const utf8 = {\n  encode: data => new TextDecoder().decode(data),\n  decode: str => new TextEncoder().encode(str)\n};\nexport const hex = /* @__PURE__ */chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(s => {\n  if (typeof s !== 'string' || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n  return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n  utf8,\n  hex,\n  base16,\n  base32,\n  base64,\n  base64url,\n  base58,\n  base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;","map":{"version":3,"names":["assertNumber","n","Number","isSafeInteger","Error","isBytes","a","Uint8Array","constructor","name","chain","id","wrap","b","c","_len","arguments","length","args","Array","_key","encode","map","x","reduceRight","decode","reduce","alphabet","digits","isArray","i","input","letter","index","indexOf","join","separator","undefined","from","to","split","padding","bits","chr","data","push","end","slice","normalize","fn","convertRadix","pos","res","forEach","d","carry","done","digit","digitBase","rounded","Math","floor","reverse","gcd","radix2carry","convertRadix2","mask","radix","num","bytes","radix2","revPadding","unsafeWrapper","_len2","_key2","apply","e","checksum","len","set","payload","newChecksum","oldChecksum","utils","base16","base32","base32nopad","base32hex","base32hexnopad","base32crockford","s","toUpperCase","replace","base64","base64nopad","base64url","base64urlnopad","genBase58","abc","base58","base58flickr","base58xrp","XMR_BLOCK_LEN","base58xmr","block","subarray","padStart","str","blockLen","j","concat","createBase58check","sha256","base58check","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","charCodeAt","v","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","TypeError","actualLength","lowered","toLowerCase","sum","sepIndex","lastIndexOf","endsWith","decodeUnsafe","decodeToBytes","encodeFromBytes","bech32","bech32m","utf8","TextDecoder","TextEncoder","hex","CODERS","coderTypeError","bytesToString","type","hasOwnProperty","stringToBytes"],"sources":["C:\\Users\\Sonam Kumari\\OneDrive\\Desktop\\AptoMed\\node_modules\\@scure\\base\\index.ts"],"sourcesContent":["/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n: number) {\n  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\ntype Alphabet = string[] | string;\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet: Alphabet): Coder<number[], string[]> {\n  return {\n    encode: (digits: number[]) => {\n      if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n        throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map((i) => {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length)\n          throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n        return alphabet[i]!;\n      });\n    },\n    decode: (input: string[]) => {\n      if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n        throw new Error('alphabet.decode input should be array of strings');\n      return input.map((letter) => {\n        if (typeof letter !== 'string')\n          throw new Error(`alphabet.decode: not string element=${letter}`);\n        const index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n        return index;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: (from) => {\n      if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n        throw new Error('join.encode input should be array of strings');\n      for (let i of from)\n        if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode(data: string[]): string[] {\n      if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n        throw new Error('padding.encode input should be array of strings');\n      for (let i of data)\n        if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n        throw new Error('padding.encode input should be array of strings');\n      for (let i of input)\n        if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!(((end - 1) * bits) % 8))\n          throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data);\n  digits.forEach((d) => {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n  });\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < digits.length; i++) {\n      const digit = digits[i]!;\n      const digitBase = from * carry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        (from * carry) / from !== carry ||\n        digitBase - digit !== from * carry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      const rounded = Math.floor(digitBase / to);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a: number, b: number): number => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const mask = 2 ** to - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    assertNumber(n);\n    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  assertNumber(num);\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), 2 ** 8, num);\n    },\n    decode: (digits: number[]) => {\n      if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n        throw new Error('radix.decode input should be array of numbers');\n      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n        throw new Error('radix2.decode input should be array of numbers');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const checksum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const newChecksum = fn(payload).slice(0, len);\n      const oldChecksum = data.slice(-len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16: BytesCoder = /* @__PURE__ */ chain(\n  radix2(4),\n  alphabet('0123456789ABCDEF'),\n  join('')\n);\nexport const base32: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\nexport const base32nopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\nexport const base32hex: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\nexport const base32hexnopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\nexport const base32crockford: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\nexport const base64: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\nexport const base64nopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\nexport const base64url: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\nexport const base64urlnopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = (abc: string) => chain(radix(58), alphabet(abc), join(''));\n\nexport const base58: BytesCoder = /* @__PURE__ */ genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\nexport const base58flickr: BytesCoder = /* @__PURE__ */ genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\nexport const base58xrp: BytesCoder = /* @__PURE__ */ genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n// legacy export, bad name\nexport const base58check = createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = /* @__PURE__ */ chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    if (typeof prefix !== 'string')\n      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n    if (words instanceof Uint8Array) words = Array.from(words);\n    if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n    if (prefix.length === 0) throw new TypeError(`Invalid prefix length ${prefix.length}`);\n    const actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    if (typeof str !== 'string')\n      throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n    if (str.length < 8 || (limit !== false && str.length > limit))\n      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\nexport const bech32: Bech32 = /* @__PURE__ */ genBech32('bech32');\nexport const bech32m: Bech32 = /* @__PURE__ */ genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\nexport const hex: BytesCoder = /* @__PURE__ */ chain(\n  radix2(4),\n  alphabet('0123456789abcdef'),\n  join(''),\n  normalize((s: string) => {\n    if (typeof s !== 'string' || s.length % 2)\n      throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n  })\n);\n\n// prettier-ignore\nconst CODERS = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof typeof CODERS;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\n\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}